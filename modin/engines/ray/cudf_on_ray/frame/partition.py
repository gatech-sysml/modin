# Licensed to Modin Development Team under one or more contributor license agreements.
# See the NOTICE file distributed with this work for additional information regarding
# copyright ownership.  The Modin Development Team licenses this file to you under the
# Apache License, Version 2.0 (the "License"); you may not use this file except in
# compliance with the License.  You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software distributed under
# the License is distributed on an "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF
# ANY KIND, either express or implied. See the License for the specific language
# governing permissions and limitations under the License.

import ray
import cudf
import cupy
import numpy as np
import cupy as cp
from modin.engines.base.frame.partition import PandasFramePartition
from pandas.core.dtypes.common import is_list_like


class cuDFOnRayFramePartition(PandasFramePartition):
    """
    A class that implements the PandasFramePartition abstract class.

    Each instance of cuDFOnRayFramePartition has four parameters:

    1. A gpu-manager object (found in gpu-manager.py).
    2. A key
    3. A length_cache
    4. A width_cache 
    """
    _length_cache = None
    _width_cache = None

    @property
    def __constructor__(self):
        return type(self)

    def __init__(self, gpu_manager, key, length=None, width=None):
        self.gpu_manager = gpu_manager
        self.key = key
        self._length_cache = length
        self._width_cache = width

    def __copy__(self):
        # Shallow copy.
        return cuDFOnRayFramePartition(
            self.gpu_manager, self.key, self._length_cache, self._width_cache
        )

    @classmethod
    def put(cls, gpu_manager, pandas_dataframe):
        """
        A class method (usually called on the class, not an instance of the class).
        This method returns the OID generated by the "put" method in gpu_manager.py
        for a particular gpu_manager and pandas_dataframe.
        Parameters
        ----------
            gpu_manager: gpu_manager
                The particular gpu_manager whose contents/store we will modify.
            pandas_dataframe: pandas.dataFrame/pandas.Series
                the pandas dataFrame object that we will use.
        Returns
        -------
            gpu_manager.put.remote(pandas_dataframe) : int
                an OID corresponding to the key generated by the put method
                in gpu_manager.py
        """
        return gpu_manager.put.remote(pandas_dataframe)

    def apply(self, func, **kwargs):
        """
        A method that returns the OID generated by the "apply" method in gpu_manager.py, using
        the key of the current cudfOnRayFramePartition.
        This OID is "stored" in gpu_manager for further reference.
        Parameters
        ----------
            func : func
                A function that we will use/apply on the dataframe obtained by the key.
            **kwargs : dict
                An iterable object that corresponds to a dict.
        Returns
        -------
            gpu_manager.apply.remote(self.get_key(), None, func, **kwargs) : int
                The result of the apply method being called in gpu_manager.py. This will
                correspond to a new key (which is stored in gpu_manager for further reference)

        """
        return self.gpu_manager.apply.remote(self.get_key(), None, func, **kwargs)

    def apply_result_non_persistent(self, func, **kwargs):
        """
        A method that returns the OID generated by the "apply_non_persistent" method
        in gpu_manager.py. This OID is "not stored" in gpu_manager.
        Parameters
        ----------
            self.get_key() : int
                The key carried by this particular cudfOnRayFramePartition
                instance, obtained with the get_key() method.
            func : func/function
                A function that we will use/apply on the dataframe obtained by the key.
            **kwargs : dict
                An iterable object that corresponds to a dict.
        Returns
        -------
            gpu_manager.apply_non_persistent.remote(self.get_key(), None, func, **kwargs) : int
                The result of the apply method being called in gpu_manager.py. This will
                correspond to a new key (this key is NOT STORED in gpu_manager, and is "non-persistent").

        """
        return self.gpu_manager.apply_non_persistent.remote(
            self.get_key(), func, **kwargs
        )

    def add_to_apply_calls(self, func, **kwargs):
        """
        A method that returns a new cuDFOnRayFramePartition that has the result
        of an apply operation done on it.
        Instead of adding to a call_queue we eagerly schedule the apply operation 
        and produce a new partition.
        Parameters
        ----------
            func : func/function
                A function that we will use/apply on the dataframe obtained by the key
                of the current cudfOnRayFramePartition
            **kwargs: dict
                An iterable object that corresponds to a dict.
        Returns
        -------
            cudfOnRayFramePartition(self.gpu_manager, self.apply(func, **kwargs))
                A new partition with the result of the apply operation done to it.

        """
        return cuDFOnRayFramePartition(self.gpu_manager, self.apply(func, **kwargs))

    @classmethod
    def preprocess_func(cls, func):
        """
        A class method which preprocesses a function
        by storing it in ray's object-store. An OID is returned,
        corresponding to the storing of the function.

        Parameters
        ----------
            func : func/function
                A function we will be storing into Ray's object-store.
        Returns
        -------
            ray.put(func) : int
                The OID corresponding to the function being added to ray's object-store.
        
        """
        return ray.put(func)

    def length(self):
        """
        A method which returns the "length" of the 
        partition.
        """
        if self._length_cache:
            return self._length_cache
        return self.gpu_manager.length.remote(self.get_key())

    def width(self):
        """
        A method which returns the "width" of the 
        partition.
        """
        if self._width_cache:
            return self._width_cache
        return self.gpu_manager.width.remote(self.get_key())

    def mask(self, row_indices, col_indices):
        """
        Lazily create a mask that extacts the indices provided.
        Args:
            row_indices: The indices for the rows to extract.
            col_indices: The indices for the columns to extract.
        Returns
        -------
            A `BaseFramePartition` object.
        """
        if (
            (isinstance(row_indices, slice) and row_indices == slice(None))
            or (
                not isinstance(row_indices, slice)
                and self._length_cache is not None
                and len(row_indices) == self._length_cache
            )
        ) and (
            (isinstance(col_indices, slice) and col_indices == slice(None))
            or (
                not isinstance(col_indices, slice)
                and self._width_cache is not None
                and len(col_indices) == self._width_cache
            )
        ):
            return self.__copy__()

        # CuDF currently does not support indexing multiindices with arrays,
        # so we have to create a boolean array where the desire indices are true.
        # TODO(kvu35): Check if this functionality is fixed in the latest version of cudf
        def iloc(df, row_indices, col_indices):
            if isinstance(df.index, cudf.core.multiindex.MultiIndex) and is_list_like(
                row_indices
            ):
                new_row_indices = cp.full(
                    (1, df.index.size), False, dtype=bool
                ).squeeze()
                new_row_indices[row_indices] = True
                row_indices = new_row_indices
            return df.iloc[row_indices, col_indices]

        iloc = cuDFOnRayFramePartition.preprocess_func(iloc)
        return self.gpu_manager.apply.remote(
            self.key,
            None,
            iloc,
            col_indices=col_indices,
            row_indices=row_indices,
        )

    def get_gpu_manager(self):
        """
        Get the gpu_manager object from the current instance of 
        cudfOnRayFramePartition.

        Returns
        -------
            self.gpu_manager : gpu_manager
                The gpu_manager object that is a part of the current
                cudfOnRayFramePartition instance.
        """
        return self.gpu_manager

    def get_key(self):
        """
        Get the key from the current instance of cudfOnRayFramePartition.
        If this key is a ray OID, then get the contents associated with the key,
        else, simply return the key.

        Returns
        -------
            self.key : int/OID
                The key that is a part of the current
                cudfOnRayFramePartition instance.
        """
        return ray.get(self.key) if isinstance(self.key, ray.ObjectRef) else self.key

    def get_oid(self):
        """
        Get the OID associated with a particular key from the gpu_manager's 
        dataframe_dict.
        Returns
        -------
            self.gpu_manager.get_oid.remote(self.get_key() : int/oid
                The gpu_manager object that is a part of the current
                cudfOnRayFramePartition instance.
        """
        return self.gpu_manager.get_oid.remote(self.get_key())

    # def get(self):
    #     """
    #     Get the gpu_manager object from the current instance of 
    #     cudfOnRayFramePartition.

    #     Returns
    #     -------
    #         self.gpu_manager : gpu_manager
    #             The gpu_manager object that is a part of the current
    #             cudfOnRayFramePartition instance.
    #     """
    #     return self.gpu_manager.get.remote(self.get_key())

    def to_pandas(self):
        """
        Get the gpu_manager object from the current instance of 
        cudfOnRayFramePartition.

        Returns
        -------
            self.gpu_manager : gpu_manager
                The gpu_manager object that is a part of the current
                cudfOnRayFramePartition instance.
        """
        return ray.get(
            self.gpu_manager.apply_non_persistent.remote(
                self.get_key(), None, cudf.DataFrame.to_pandas
            )
        )

    def to_numpy(self):
        """
        Convert the object stored in this partition to a NumPy array.
        Note: If the underlying object is a Pandas DataFrame, this will return
            a 2D NumPy array.
        Returns
        -------
            A NumPy array.
        """
        def convert(df):
            if len(df.columns == 1):
                df = df.iloc[:, 0]
            if isinstance(df, cudf.Series):  # convert to column vector
                return cupy.asnumpy(df.to_array())[:, np.newaxis]
            elif isinstance(
                df, cudf.DataFrame
            ):  # dataframes do not support df.values with strings
                return cupy.asnumpy(df.values)

        return self.gpu_manager.apply_result_not_dataframe.remote(
            self.get_key(),
            convert,
        )

    """
    A method which gets rid of a dataframe,
    using the key associated with this particular
    cudfOnRayFramePartition instance, 
    from the gpu_manager dataframe dictionary.
    """
    def free(self):
        self.gpu_manager.free.remote(self.get_key())

    def copy(self):
        new_key = self.gpu_manager.apply.remote(
            self.get_key(),
            lambda x: x,
        )
        new_key = ray.get(new_key)
        return self.__constructor__(self.gpu_manager, new_key)

    # TODO(kvu35): buggy garbage collector reference issue #43
    # def __del__(self):
    #     self.free()
